# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Красоткин С.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

## Введение

Доселе я активно сталкивался с парадигмой императивного программирования, немного с функциональным. Но есть и другие, например, логическое. Для каждого есть свои языки, правила. Сейчас мне требуется ознакомиться с парадигмой логического программирования, изучая принцип работы декларативного языка Prolog, как с его помощью записывать
факты, предикаты и запросы к ним.

## Задание

В курсовой надо сделать по порядку следующие задания:

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: `a.child(ребенок, родитель), male(человек), female(человек).` [Вариант 3]
 3. Реализовать предикат проверки/поиска золовки (сестра мужа) 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве. 
 5. Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы.

## Получение родословного дерева

Генеалогическое дерево получено благодаря сайту помощи сайта MyHeritage.com. Не  составлял собственное, так как тяжело
опросить всех родственников, особенно 4-юродных, согласны ли они признать своё родство со мной, поэтому решил взять родственников польского короля Владислава II Ягелло, но слегка увлёкся и сайт показал, что я занёс в дерево 109 людей.

## Конвертация родословного дерева

Увы, выполнял эту курсовую работу в мае, в разгар
зачётной недели. Поэтому, как мне не хотелось сделать конвертор на Prolog, пришлось брать то что проще — Python. Удобный скриптовый язык. Как раз подходящий для задач такого
рода.

Программа проходит построчно по файлу и ищет id персоны. Видит её имя и фамилию и запоминает, а также какого пола человек. Если  находит семью, то ищет детей. По факту после прохождения всего файла напечатаны предикаты
female и male и child.

## Предикат поиска родственника

По варианту требовалось найти *золовку* (сестра мужа). Для этого нужно проверить женскость обоих полов, предикат мужа и сестры.

    sister_in_law(X, Y) :- female(X), female(Y), husband(X,
    Z), sister(Z, Y).
    husband(X, Y) :- wife(Y, X).
    wife(X, Y) :- male(X), female(Y), child(Z, X), child(Z,
    Y).
    sister(X, Y) :- female(Y), child(Y, Z), child(X, Z), X
    \= Y.

Заодно реализовал предикаты поиска других родственных отношений. Пригодится для дальнейших заданий.
```
Результат работы программы (Первые 10 выводов):
sister_in_law(X, Y)
X = 'Иулиания Александровна',
Y = 'Евфремия Гедимин'
X = 'Иулиания Александровна',
Y = 'Евфремия Гедимин'
X = 'Елизавета Габсбург',
Y = 'Елизавета Бонифация'
X = 'Елизавета Габсбург',
Y = 'Елизавета Бонифация'
X = 'Елизавета Габсбург',
Y = 'Елизавета Бонифация'
X = 'Елизавета Габсбург',
Y = 'Елизавета Бонифация'
X = 'Елизавета Габсбург',
Y = 'Ядвига Ягайло'
X = 'Елизавета Габсбург',
Y = 'Ядвига Ягайло'
X = 'Елизавета Габсбург',
Y = 'Ядвига Ягайло'
X = 'Елизавета Габсбург',
Y = 'Ядвига Ягайло'
X = 'Мария Бургундская',
Y = 'Елизавета Австрийская'
```
## Определение степени родства

В прошлом разделе уже написал несколько предикатов родства. В этом добавил ещё общий предикат `relate(R, X, Y)`. Он принимается список родственных отношений и проверяет
заходит X в такую цепочку до Y. С этого можно заодно определить их родство. Используется поиск в ширину. Также можно определить родство X и Y. bfs - предикат поиска в
ширину.

    perm(X, Y) :- relative(_, X, Y).
    prlng([X|T], [Y, X|T]) :- perm(X, Y), not(member(Y,
    [X|T])).
    bfs([[H|T]|_], H, [H|T]).
    bfs([H|T], RES, TREE) :-
    findall(W, prlng(H, W), TREES),
    append(T, TREES, NEWTREES), !, bfs(NEWTREES, RES,
    TREE).
    find([_], R, R).
    find([X,Y|T], R, REL) :-
    relative(RE, X, Y),
    find([Y|T],
    [RE|R], REL).
    relate(REL, X, Y) :-
    bfs([[X]], Y, R),
    reverse(R, RE),
    find(RE, [], NEWREL),
    reverse(NEWREL, REL),
    N is 0.

UPD: При работе над 5-м заданием bfs показал себя крайне неэффективно. Во-первых работал медленее, а во-вторых, на некоторых запросах падал, поэтому переделал под итеративный поиск. Он выдаёт более приятные результаты по производительности.

Результат работы программы:

> relate('Элеонора Медичи', 'Мария Медичи')
> sister
> 
> relate('Лукреция Медичи', 'Казимир Ягеллончик')
> greatgreatgrandfather

## Естественно-языковой интерфейс

Предикат `question(L)` принимает список вида и выводит на экран ответ. Предикат `word(X) `определяет является ли X словом из заданного списка, также и для предикатов `have(X)` и
`question_word(X)`. Предикат `have_lst([X], R)`, проверяет принадлежность X списку из R.

    word(X) :- member(X, [whose, "Whose"]).
    have(X) :- member(X, [is, "Is"]).
    have_lst([X], REL) :- member(X, [REL]).
    question_word(X) :- member(X, ['?']).
    prev_set(NAME) :- nb_setval(name, NAME).
    word_prev(X) :- member(X, "His",his,"Him",him,"Her",her,"She",she,"He",he]), !.
    to_word(X) :- member(X, ["to", to]).

UPD: Для увеличения возможности задавать вопросы введена КС-грамматика. Вначале из фразы выделяются ключевые слова. Они обрабатываются и выводится ответ. 

Результат работы программы:

> ask(['Is', 'Юрий Болеслав', 'Мария Галицкая', "'s", 'son', '?'], X).
> true
> 
> ask(['Is', 'Юрий Болеслав', 'Мария Галицкая', "'s", 'daughter', '?'], X).
> false
> 
> ask(['Who is', 'Иоанна Австрийская', "'s", 'mother', '?'], X).
> X = 'Анна Ягеллонка'
> 
> ask(['Who is', 'Иоанна Австрийская', "'s", 'greatgreatgranddaughter', '?'], X).
> X = 'Анна Мария Орлеанская'
> X = 'Генриетта Стюарт'
> X = 'Анна Стюарт'
> X = 'Анна Мария Орлеанская'
> 
> ask(['How many', 'sons', 'does', 'Казимир Ягеллончик', 'have', '?'], X).
> X = 4

## Выводы
С парадигмами, отличными от императивных, уже был немного знаком, так как немного касался Haskell, но с логическим впервые, поэтому было непросто. Особенно, что материал учил не по лекциям, а по статьям фрагментам кода из Интернета и документациями.
Мне понравилось использовать различные средства Пролога: списки, вычисление предикатов.
Решать логические задачи обычно не приходится, но в последнем задании работал с языком, в чём есть реальный практический смысл.


