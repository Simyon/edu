# Реферат
## по курсу "Логическое программирование"

### студент: Красоткин С. А.

## Тема: Как научить вашу бабушку/дедушку Логическому программированию

## Результат проверки


| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

## Введение

Быть преподавателем — просто. Быть хорошим преподавателем — сложно. Нужно уметь терпеливо доступно излагать порой чрезвычайносложный материал. Непросто обучать того, чей накопленный жизненный опытсам является уроком для меня, например. Речь идёт о бабушках, дедушках. Понятное дело, что это не конкретные предки 2-го поколения вверх по родительскому древу, но полагается, что они уже пожили, попутно приобретя мудрость ноещё имея жажду познания, и в силу разных обстоятельств (возраста) к ним требуется деликатный подход. В изложении отсеим страдающих приобретённым слабоумием, а именно болезнью Альцгеймера, а также просто со сложным характером.

Что деды, что ребята — все любят играть, это попросту интересно. Превратив обучение в игру, ученику будет легче усваивать материал.

## Основы
На самом деле в программировании можно выделить несколько направлений, также известные как парадигмы:
* Структурное:
    * Программа разбивается на блоки — изолированные подпрограммы;
    * Основные элементы управления:
        * Последовательность команд
        * Ветвление
        * Цикл
* Объектно-ориентированное:
    * Задача моделируется в виде взаимосвязи объектов. Они имеют:
        * Свойства
        * Методы
* Функциональное:
    * База — функция. Задача формулируется в этих терминах и аргументы функций — функции.
* Логическое.
    * В его основе — логика предикатов первого порядка. То есть для решения задачи, её необходимо описать на подмножестве предикатов (правил). На них будет основывать программа или какой-нибудь логический интерпретатор с целью автоматического выводаответа на данную задачу.

Чем же так прекрасен язык логики? Конечно же широким применением:
* Использование для искусственного интеллекта
* Анализ естественного языка
* Представление и обработка знаний
* Компьютерная алгебра
* Символьные вычисления

Окей, основы нашему ученику изложены, теперь его можно познакомить со стилями.

## Декларативное и императивное программирование

Существуют стереотип, что бабушки любят готовить. Поверим ему прямо сейчас и предложим нашим ученицам приготовить друны. И на примере этого блюда рассмотрить разность стилей.

### Императивный стиль
Для этого стиля программирования очень важно описание как достичь результата, каждый его шаг. Например, рецепт друнов можно записать следующим образом:
1. Почистить и помыть картошку. 
2. Натереть на крупной тёрке. 
3. Вбить яйца, добавить муку, посолить (на 6-7 средних картофелин 1 чайной ложки соли без верха)
4. Добавить молотый чёрный перец. 
5. Перемешать и подождать (10 минут). 
6. Выкладывать тесто ложкой и обжарить с двух сторон на среднем огне до румяной корочки (по 7 минут). 
7. Подать на стол.

### Императивный стиль
В таком стиле описывается какой именно результат требуется получить. То есть получатель получает сообщение. Дальше сам разбирается, что для этого нужно сделать. Программа тут будет выглядеть так:
1. Приготовить друны.

Дальше она сама на заложенных фактах должна делать результат.

Наверняка почти всем людям преклонного возраста известны числа. Чтобы поддерживать ум в цельном состоянии полезно проивзодить над ними операциям. Для этого отлично подходит вычисление факториала: последовательноное перемножение чисел. Но вот засада, значение этой операции быстро растёт, поэтому необходимо каким-нибудь способом проверть. Для этого отлично подходит программирование. Как раз тут и проиллюстрирую разность императивного стиля с декларативным.
| Императивный | Декларативный |
|---|---|
| ```long long fact, f = 1;```|```fact(0,0)``` 
```for(int i = 1; i <= n; i++)```|```fact(N,F) :- N1 is N-1,```
```f *= i```|```fact(N1,F1) , F is F1*N```
```fact := f;``` |```fact(N) = F :- ```  
```return 0```|```(N=0 → F=1; F is fact(N-1)*N)```

В декларативном стиле, программа похоже на классическое определение факториала и не требует тонкностей языка по типу выделения отдельной переменной для мемоизации результата умножения. Если интересно узнать чему равен факториал шести (6!) с помощью программы, написанной в декларативном стиле достаточно напечатать:
```
?-fact(6,X)
X = 720 
```
Но тут обучаемый нами старик может посмотреть на это внимательно и предъявить смешение стилей: с использованием рекурсивной процедуры:
```
Function fact(n: long long) : long long;
{
    (n == 1) ? fact := 1 : fact := fact(n-1)*n;
}
```
У обучаемого возникает вопрос, а в чём разница между стилями. И в самом деле настоящие языкы высокого уровня позволяют смешение стилей. Но одни более декларативны, другие более императивны. Теперь перейдём к языкам программирования.

## Языки программирование и их история
Программирование хоть и основано на древних науках, как математика и логика, но относительно их достаточно молодо. Обычно считают,что оно зародилось в середине прошлого века, но предтечи были ещё в середине XIX века:
1. Тогда Чарльз Беббидж и Ада Лавлейс разработали принцип императивного: набор команд, послуживший фундаментом  для современных ЭВМ и определил гегемонию одного из стилей.
2. ЭВМ стали появляться в 1940-х годах и программировались при помощи машинных языков, состоящий из последовательности 0 и 1. Каждая элементарная операция имела свой код, необходимо было явно указывать адреса ячеек памяти, в которых хранились данные и куда их необходимо было сохранять.
3. В начале 1950-х годов была осуществлена идея использования символьных имён вместо адресов данных и замены цифровых кодов операций на мнемонические обозначения. Язык программирования, реализующий данный подход, получил название Ассемблер. Программа на Ассемблере не обрабатывается непосредственно процессором, поэтому создали трансляторы.
4. Позже появились такие яызки программирования высокого уровня, определивших дальнейшее развитие: Fortran, COBOL и Lisp.
5. Затем появились императивные языкы C, Pascal. В них ввели понятие типов данных, распределение памяти для переменных, оператор присваивания.
6. В 1970-х появился декларативный язык программирования Prolog. 
7. Объектно-ориентированный язык программирования С++ появился в 1980-х годах и до сих пор пользуется популярен. 
8. В 1990-ые появились: Java, Haskell, С#, Mercury. Последний является усовершенствованным потомком  Prologa и прямо сейчас его считают наиболее декларативным из всех существующих языков.

Это, конечно, увлекательно. Но наш пожилой студент уже рвётся решать задачи. Не будем ему мешать.

## Системы логического программирования
Часто передвигаюсь в метро, по крайней мере когда выходил из дому, и вижу, что старушки очень любят читать детективы. Но что является чем-то, что намного интереснее. Естественно логические задачи. 
Вот пример: 
> Как-то раз случай свел в купе известного астронома, поэта, прозаика и драматурга. Это были Алексеев, Борисов, Константинов и Дмитриев. Оказалось, что каждый из них взял с собой книгу, написанную одним из пассажиров этого купе. Алексеев и Борисов углубились в чтение, предварительно обменявшись купленными книгами. Поэт читал пьесу. Прозаик, очень молодой человек, выпустивший свою первую книгу, говорил, что он никогда ничего не читает по астрономии. Борисов купил в дорогу одно из произведений Дмитриева. Никто из пассажиров не покупал и не читал книги, написанные им самим. Что читал каждый из них? Кто кем был?”

Кажется сперва трудным, но всё по порядку. Скажем системы, кого имеем:
```
surname(alekseev).
surname(borisov).
surname(konstantinov).
surname(dmitriev).
```

Что имеем
```
book(astronomy).
book(poetry).
book(prose).
book(piece).
```
Мы хотим получить в качестве результата список кто есть кто, поэтому каждый должен входить в него единожды:
```
no_repetitions([]):-!.
no_repetitions([Head|Tail]):-
member(Head, Tail), !, fail;
no_repetitions(Tail).
```
Думать за нас будет машина. Займётся этим следующий предикат:
```
solve(Solve) :-
Solve = [passenger(X, XRead, XBuy, XWrite), passenger(Y, YRead, YBuy, YWrite),
passenger(Z, ZRead, ZBuy, ZWrite), passenger(W,WRead, WBuy, WWrite)],
```
В него запишем, что у нас 4 разных пассажира:
```
surname(X), surname(Y), surname(Z), surname(W),no_repetitions([X, Y, Z, W]),
```
У каждого своя книга:
```
book(XWrite), book(YWrite),
book(ZWrite), book(WWrite),
no_repetitions([XWrite, YWrite, ZWrite, WWrite]),
```
Каждый купил книгу
```
book(XBuy), book(YBuy),
book(ZBuy), book(WBuy),
no_repetitions([XBuy, YBuy, ZBuy, WBuy]),
```
Каждый читает книгу
```
book(XRead), book(YRead),
book(ZRead), book(WRead),
no_repetitions([XRead, YRead, ZRead, WRead]),
```

Каждый не читал и покупал свою книгу
```
check(Solve),
```
Поэт читает пьесу:
```
member(passenger(_, piece, _, poetry), Solve),
```
Прозаик читает не астрономию
```
not(member(passenger(_, astronomy, _, prose), Solve)),
```
Прозаик не покупал астрономию
```
not(member(passenger(_, _, astronomy, prose), Solve)),
```
Алексеев и Борисов обменялись книгами
```
member(passenger(alekseev, AlekseevRead, AlekseevBuy,_), Solve),
member(passenger(borisov, AlekseevBuy, AlekseevRead,_), Solve),
```
Борисов купил произведение Дмитриева
```
member(passenger(dmitriev, _, _, DmitrievWrite),Solve),
member(passenger(borisov, DmitrievWrite, _, _),Solve).
```
После этого запишем предикат проверки:
```
check([]) :- !.
check([passenger(_, XRead, XBuy, XWrite)|T]):-
check(T),!,not(XRead = XWrite), not(XBuy = XWrite).
```
Всё условие записали. Переносим код в онлайн-исполнитель Prolog и пишем во входной строке `solve(Solve).` Теперь лёгким нажатием клавишы enter разгадаем эту задачу. 
```
?- solve(Solve).
Solve = [passenger(alekseev, prose, piece, astronomy), passenger(borisov, piece, prose, poetry), passenger(konstantinov, poetry, poetry, prose), passenger(dmitriev, astronomy, astronomy, piece)] 
```
Вуаля, Алексеев читал прозу, купил пьесу, а написал астрономию; Борисов читал пьесу, купил прозу, но писал стихи; Константинов читал стихи их же купил, хотя написал прозу; Пассажир Дмитриев купил и читал астрономию, написав книгу по пьесе.

## Заключение

Нельзя объять не объятное, как и уместить курс логического программирования в этот реферат.
Но первый шаг, как известно трудный самый, сделан. И положа руку на сердце, возможно, скорее всего бабушки и дедушки не будят после этого ежедневно писать программы на Prolog. Однако отныне при столкновении с логической проблемой в их арсенале прибавился инструмент.
